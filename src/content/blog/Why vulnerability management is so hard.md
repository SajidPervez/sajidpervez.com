---
layout: ../../layouts/MarkdownPostLayout.astro
title: 'Why vulnerability management is so hard?'
pubDate: 04-10-2024
description: 'Vulnerability management issues and potential solutions'
author: 'Sajid Pervez'
isDraft: false
cover:  "../images/vulnerabilities-universe.jpg"
altText: "Why vulnerability management is so hard?"
tags: ["vulnerability management", "vulnerability scanning", "cybersecurity", "threat detection","patch management", "vulnerability remediation"]
canonicalURL: "https://localhost:4321/blog/Why-vulnerability-management-is-so-hard"
---
Coming from product security engineer lens, vulnerability management is seen as one of the metrics used by the leadership at organizations to assess the security health of their products. On those metrics, mostly SLA's are being reported with some form of remediation times. That's fine, but its a constant battle that teams are fighting all the time because of the speed at which scanner finds these vulnerabilities and humans fixing those.

> *Fixing security issues is not just a technical problem; people and process are also required to get it done. Caroline Wong*

Lets start.
## What is not a problem
* Finding vulnerabilities 

## What are the problems and soltuions
1. Multiple sources
2. Priortization
3. Remediation woes
4. The Forgotten ones

### 1. Multiple sources
There are tow issues here. First one is multiple sources to look at and use e.g. a SAST scanner, infra scanner, dependecies, containers, etc. Whilst that can be resolved with the help of vulnerability aggregator like [OWASP DefectDojo](https://www.defectdojo.org/), but I have seen instances where multiple similar types of scanners scanning the assets and reporting a CVE either with varying severity or one scanner not even picking up a critical vulnerability. This situation is rare though and easy to solve by taking a decision on using single scanner for a specific type of scanning.

### 2. Priortization
Priortization can be a problem if organization assets are not catalogued in a strucutred way to either get contextual information easily from one place and provide it to the vulnerability management platform (if there is one running at the org, otherwise thats another problem) or enrich the scanner with it (Its not an easy task, another appsec challange to solve). Assuming that assets made up of different types of components (code and infra) are catalogued with contextual information such as owner, network and data etc. priortization can become a bit easier to solve.

Take aways here would be:
* No orphan assets - Define owners either via tagging strategy, github stats or some asset cataloguing tool such as [Atlassian Compass](https://www.atlassian.com/software/compass) or [Backstage](https://backstage.io/).
* Add meta data to assets - Assets with meta data such as network exposure, data sensitivity, business criticality adds the necessary context for right level of risk assessment
* Use asset meta data with tool like Stake-holder specific vulnerability catagorization calculator ([SSVC Calculator](https://www.cisa.gov/ssvc-calculator))

### 3. Remediation woes
Once we have solved the people and process problem from above, we stumble upon the bucket of scanners; which are all of different types from commerical to open-source using variety of vulnerability databases and hence provides advice from specific line of code fix to a generic advice on patching some libraries or reporting a vunerability on some software that is hard to find on a machine.

Whilst priortization reduces remediation woes to a some extent we still need to help developers with better advice. Easier said than done, but one **expensive** way is to provide pricy scanning tools or a vulnerability aggregation tool (which has its very own unique sets of issues) but that may not be an option for many out there. In that case, see if below points can help:

* Understand the vulnerability better - Use chatGPT to your advantage
* Triage better to measure or understand the scope, it can be a false-positive
* Remove unnecessary dependecies or libraries or software - developers tend to add many over time
* Define and be specific about dev dependencies
* For a zero-day vuln, apply segmentation using network rules and monitor

### 4. The Forgotten ones
Vuln. management program always have a final step or an exit door called *suppression* or *exceptions* or some refer to it as "acceptance" process. Usually vulnerabilities are risk accepted or suppressed for few reasons:

* False positives - thats easy and should be added to the forgotten list
* Product team is more featured focused - they need more handholding from security and the leadership team
* Legacy product with decommission on the horizon

Of the above, its last one that usually seeks suppresion or acceptance and if vulns are not automatically tracked, they become the forgotten ones. Vuln. aggregation tools help in such a situation otherwise tracking becomes challanging.

